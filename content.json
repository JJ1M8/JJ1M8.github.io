{"meta":{"title":"JJ1M8","subtitle":"","description":"我是僵尸，我要当一个厉害的人","author":"LSJ","url":"http://jj1m8.github.io","root":"/"},"posts":[{"tags":[{"name":"编码之外","slug":"编码之外","permalink":"http://jj1m8.github.io/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"},{"name":"日记","slug":"日记","permalink":"http://jj1m8.github.io/tags/%E6%97%A5%E8%AE%B0/"}],"title":"2020-4-4 悼念我们的英雄","date":"2020/04/04","text":"2020年初，我们都经历了太多太多我们看见病毒在人间肆虐，看见多少人失去亲人、朋友。我们更看见各个行业都有人在做着自己力所能及的事情，医生们更是冒着生命危险在救治病人，他们都是我们的英雄。今天是清明节，举国默哀，悼念我们的英雄。","permalink":"http://jj1m8.github.io/2020/04/04/2020-4-4-%E6%82%BC%E5%BF%B5%E6%88%91%E4%BB%AC%E7%9A%84%E8%8B%B1%E9%9B%84/","photos":[]},{"tags":[{"name":"编码之外","slug":"编码之外","permalink":"http://jj1m8.github.io/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"title":"策爷拿到日本offer","date":"2020/04/03","text":"恭喜恭喜策爷我和我的好朋友沈策，今天去海边玩耍，得知一个好消息，策爷拿到了去日本留学的offfer，是早稻田大学。恭喜恭喜啊，努力就会有回报这句话果然没有错！还有就是苟富贵勿相忘啦哈哈哈 自己也要继续努力确实看到身边的人，有的拿了offer，有的保研了，有些人做得毕业设计使用的东西自己都看不懂了，还是只会在家玩游戏，确实不应该。既然自己能够知道自己的不足，那赶紧努力追赶上吧！","permalink":"http://jj1m8.github.io/2020/04/03/%E7%AD%96%E7%88%B7%E6%8B%BF%E5%88%B0%E6%97%A5%E6%9C%ACoffer/","photos":[]},{"tags":[{"name":"服务器","slug":"服务器","permalink":"http://jj1m8.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://jj1m8.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"毕设","slug":"毕设","permalink":"http://jj1m8.github.io/tags/%E6%AF%95%E8%AE%BE/"}],"title":"使用花生壳+树莓派实现内网穿透","date":"2020/04/03","text":"最近在做毕设的过程中，在内网使用树莓派以及esp8266搭建了内网的智能家居系统，想要实现本人不在家中，也能通过外网对家里的智能家居系统进行访问。最后本人选择的方案是使用花生壳进行内网穿透。选择原因：花生壳赠送一个域名，能够免费进行远程桌面，远程连接树莓派的内网穿透，如果想要穿透web的http协议也仅需6元即可永久开通开始之前给出花生壳官方参考资料地址，里面的教程更加详细。 一、树莓派下载花生壳客户端：在树莓派上下载花生壳可以参照这一步骤：安装花生壳注意：在树莓派上，一定要先将安装完成时的sn码和初始密码用来登录（类似一个绑定的操作，否则可能出现一直提示请检查服务器是否运行）如果是已有账号的小伙伴也需要这一步，放心之后可以将账号再绑定上去。 二、启动花生壳服务，注册账号输入phddns start 命令启用花生壳默认内置帐号只有公网版服务，如需使用内网穿透功能，要自行开通 三、进入控制台，设置要穿透的内网如果选择http需要6元 四、诊断看看是否运行成功恭喜啦，到这一步没什么问题的话就成功啦！","permalink":"http://jj1m8.github.io/2020/04/03/%E4%BD%BF%E7%94%A8%E8%8A%B1%E7%94%9F%E5%A3%B3-%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day17：高阶函数：map、reduce、sorted、fliter、lambda","date":"2020/04/03","text":"一、mapmap(fn,lsd)fn: 可以是自己写的，也可以是系统自带的lsd: 一个序列功能：把lsd中每一个元素分别作用在fn上 例如：字符串列表变为int列表 \"\"\"map(fn,lsd)fn: 可以是自己写的，也可以是系统自带的lsd: 一个序列功能：把lsd中每一个元素分别作用在fn上\"\"\"#比如变为int列表L = [\"1\",\"2\",\"3\",\"4\",\"5\"]L1 = []for var in L: L1.append(int(var))print(L1)res = list(map(int,L)) #分配进行处理，即把L都用int转换成int型print(res)def convert(key): dict1 = &#123;\"1\":1,\"2\":2,\"3\":3,\"4\":4,\"5\":5,\"6\":6&#125; return dict1[key]res = list(map(convert,L))print(res) 二、reducereduce(fn,lsd)fn: 一个函数lsd: 一个序列功能：把lsd中的每一个元素一次作用在fn上，fn必须有两个参数执行流程：lsd的前两个元素作用在fn上，然后得到一个结果，得到的结果在和第三个数组成两个数作用在fn上，以此类推直到lsd中的所有元素计算完毕 例如：把列表reduce成数 \"\"\"reduce(fn,lsd)fn: 一个函数lsd: 一个序列功能：把lsd中的每一个元素一次作用在fn上，fn必须有两个参数执行流程：lsd的前两个元素作用在fn上，然后得到一个结果，得到的结果在和第三个数组成两个数作用在fn上，以此类推直到lsd中的所有元素计算完毕\"\"\"# 例如把列表reduce成数from functools import reduceL = [1, 2, 3, 4, 5]def func(a, b): return a * 10 + bres = reduce(func,L)print(res,type(res))L = [\"1\",\"ad3\",\"c2\",\"h2o\",[\"co2\",\"k2mo4\",\"na2\"],34]#将数字放入L1中L1=[]for var in L: #判断是否是字符串 if isinstance(var,str): for val in var: if val.isdigit(): L1.append(val) #判断是否是列表 elif isinstance(var,list): #遍历二级列表 for val in var: if isinstance(val,str): for i in val: if i.isdigit(): L1.append(i) #如果是数字直接添加 else: L1.append(var)print(L1)#然后将L1转换成一个整数(map和reduce一般配合使用res = list(map(int,L1))print(reduce(func,res)) 三、sorted用于排序sort和sorted的区别sort是无返回值的sorted是有返回值的 \"\"\"sort和sorted的区别sort是无返回值的sorted是有返回值的\"\"\"L = [3,5,-856,7645,-32,1]# L.sort()# print(L)res = sorted(L)print(res)#sort和sorted都可以加key参数，采用指定的方式进行排序res = sorted(L,key=abs)print(res) 四、filterfilter(fn,lsd)功能：过滤执行流程：lsd中的每一个元素一次作用在fn上，如果返回True;那就保留该数据，如果返回Flase，则过滤掉这个数据 \"\"\"filter(fn,lsd)功能：过滤执行流程：lsd中的每一个元素一次作用在fn上，如果返回True;那就保留该数据，如果返回Flase，则过滤掉这个数据\"\"\"lsd = [1,2,3,4,5,6,7,8,9]def func(key): return key%2 == 0res = filter(func,lsd)print(res) #&lt;filter object at 0x00000180BA325780&gt;print(list(res)) #序列化res = list(filter(func,lsd)) #直接在过滤后转换print(res) 五、lambdalambda 表示式是一种简洁格式的函数 这个表达式不是正常的函数结构，而是属于表达式的类型lambda 参数1，参数2：函数功能代码 一般只会用于实现简单功能 \"\"\"lambda 表示式是一种简洁格式的函数 这个表达式不是正常的函数结构，而是属于表达式的类型lambda 参数1，参数2：函数功能代码一般只会用于实现简单功能\"\"\"from functools import reduceres = lambda x,y:x+yprint(res(1,2)) #类似于宏定义res = lambda sex:\"胡子\" if sex == \"man\" else \"mei胡子\"print(res(\"man\")) 六、整合练习求lsd列表当中偶数组成的最大整数以及奇数组成的最小整数 最后，尝试一句话实现功能 lsd = [\"1\",\"2\",\"3\",\"4\",\"7\",\"8\",\"9\"]#求偶数的最大整数res = map(int,lsd) #转换为intvar = filter(lambda x:True if x%2==0 else False,res)val = sorted(var, reverse=True)#对数据整合def func(a,b): return a*10 + bres1 = reduce(func,val)print(res1)#求奇数的最小整数res = map(int,lsd) #转换为intvar = filter(lambda x:True if x%2==1 else False,res)val = sorted(var,reverse=False)res2 = reduce(func,val)print(res2)#求奇数的最小整数print(reduce(lambda x,y:x*10+y,sorted(filter(lambda x:True if x%2==1 else False,map(int,lsd)),reverse=False)))","permalink":"http://jj1m8.github.io/2020/04/03/day17%EF%BC%9A%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%9Amap%E3%80%81reduce%E3%80%81sorted%E3%80%81fliter%E3%80%81lambda/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day16：army小练习、@property、动态添加属性和方法、限制添加属性、__repr__和__str__、类方法和静态方法","date":"2020/04/03","text":"一、army小练习使用面向对象，实现army练习创建一支军队：骑兵、法师、弓箭手将军可以下达命令指挥军队 \"\"\"创建一支军队：骑兵、法师、弓箭手将军可以指挥军队下达命令\"\"\"class Cavalry: def attack(self): print(\"My iron rides on you!\") def defend(self): print(\"cavalry defend!\")class Archer: def attack(self): print(\"My arrow is extremely accurate!\") def defend(self): print(\"archer defend!\")class Magician: def attack(self): print(\"My magic is infinite!\") def defend(self): print(\"magician defend!\")if __name__ == '__main__': army = [] c = Cavalry() m = Magician() a = Archer() army.append(c) army.append(a) army.append(m) order = input(\"please order the army:\") if order == \"attack\": for var in army: var.attack() elif order == \"defend\": for var in army: var.defend() elif order == \"flatten it\": for var in army: if isinstance(var,Cavalry): var.attack() else: var.defend() elif order == \"shoot it\": for var in army: if isinstance(var,Archer): var.attack() else: var.defend() elif order == \"magic it\": for var in army: if isinstance(var,Magician): var.attack() else: var.defend() else: print(\"The wind is too hard to hear the order!\") 运行效果please order the army:magic itcavalry defend!archer defend!My magic is infinite! 二、@property把一个方法当做属性来用例如在方法前加上@property会导致私有属性去私有化 使用@age.setter注意，三个age，必须是相同的 #把一个方法当做属性来用class Person: def __init__(self,n,age): self.name = n self.__age = age @property def age(self): return self.__age @age.setter #注意，三个age，必须是相同的 def age(self,n): self.__age = nif __name__ == '__main__': p = Person(\"小红\",18) print(p.name) #通过property可以像属性一样使用 p.age = 21 print(p.age) #导致私有属性去私有化 三、动态添加属性和方法动态添加属性：类内没有的属性，可以直接添加 #动态添加属性class Person: passdef tell(self): print(\"my name is %s\"%self.name)if __name__ == '__main__': p = Person() #动态添加一个属性给当前实例,仅限于当前实例访问，其他实例不可以访问 p.name = \"js\" print(p.name) 动态添加方法：需要引用from types import MethodType可以将一个类外的函数绑定给对象tell是要绑定的函数，p是函数绑定到被指定的实例 p.speak = MethodType(tell,p) #可以把一个方法动态的添加from types import MethodType#动态添加属性class Person: passdef tell(self): print(\"my name is %s\"%self.name)if __name__ == '__main__': p = Person() #动态添加一个属性给当前实例,仅限于当前实例访问，其他实例不可以访问 p.name = \"js\" print(p.name) #动态添加方法 #tell是要绑定的函数，p是函数绑定到被指定的实例 p.speak = MethodType(tell,p) p.speak() 四、限制添加属性在类内添加slots = (“name”,)可以现在添加属性，注意这里是元祖。 class Person: #限制添加属性 __slots__ = (\"name\",) #注意这里是元祖，就算只有一个元素也必须要添加逗号 def __init__(self,name,age): self.name = name self.age = ageif __name__ == '__main__': p = Person(\"js\",11) #AttributeError: 'Person' object has no attribute 'age' 五、repr和str当调用print打印实例的时候，才会调用str而repr在文件交互模式下输入实例，按下回车的时候会自动调用 class Test: def __init__(self,name = \"jack\",age = 19): self.name = name self.age = ageclass TestStr(Test): def __repr__(self):#当str不存在的时候，repr=str return \"__repr__: %s,%s\"%(self.name,self.age) def __str__(self): return \"__str__: %s,%s\"%(self.name,self.age)t = TestStr()print(t.name)print(t) #当调用print打印实例的时候，才会调用str#而repr在文件交互模式下输入实例，按下回车的时候会自动调用 六、类方法和静态方法它们都可以直接通过类名来调用在写接口的时候，会使用这样的方法，这样就不用一直创建实例来调用le class Person: #类属性 name = \"jeck\" def __init__(self,name): self.name = name def tell(self): #self 接收的是rose print(self.name) @classmethod def say(cls): #cls接收类，打印类属性 print(cls.name) @staticmethod def talk(): # print(Person.name)if __name__ == '__main__': p = Person(\"rose\") p.tell() #rose p.say() #jeck p.talk() #jeck Person.tell(p) #rose 这种写法不实用 Person.say() #jeck Person.talk() #jeck 练习 class Date: def __init__(self,year = 0,month = 0,day = 0): self.year = year self.month = month self.day = day def show(self): print(self.year,self.month,self.day) @staticmethod def get_date(string_date): year, month, day = string_date.split(\"-\") date1 = Date(year,month,day) #这里必须为类名，如果类名变化，也需要变化 return date1 @classmethod def get_dateL(cls,string_date): year, month, day = string_date.split(\"-\") date1 = cls(year, month, day) #这里为cls而不是类名，可以随意修改类名 return date1if __name__ == '__main__': \"\"\" 假设用户输入2020-3-13 \"\"\" t = Date.get_date(\"2020-3-13\") t.show() t = Date.get_dateL(\"2020-3-13\") t.show() 注意：当需要对输入进行分割用split","permalink":"http://jj1m8.github.io/2020/04/03/day16%EF%BC%9Aarmy%E5%B0%8F%E7%BB%83%E4%B9%A0%E3%80%81-property%E3%80%81%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E3%80%81%E9%99%90%E5%88%B6%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E3%80%81-repr-%E5%92%8C-str-%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day15：面向对象","date":"2020/04/03","text":"一、面向对象面向对象，更加注重过程的编程方法面向对象三大特性：封装，继承，多态py中所有的类都继承与一个父类 1、使用class建立类#class 类class Person: pass 给类加入属性： #属性 name = “js” age = 18 hair = “black”给类加入方法： def tell(self) #class 类class Person: #属性 name = \"js\" age = 18 hair = \"black\" #方法 self：谁调用就是谁 def tell(self): print(\"my name is %s,age %s,hair is %s\"%(self.name,self.age,self.hair)) pass 2、实例化对象使用 类名() 表示实例化一个对象 p = Person()print(p.name)p.tell() 3、使用构造方法构造方法能够在实例化时就初始化实例 #class 类class Person: #属性 name = \"js\" age = 18 hair = \"black\" #构造方法：在实例化的时候自动调用 #如果定义了构造器则没有默认的缺省的构造器了 def __init__(self,name,age): self.name = name self.age = age #方法 self：谁调用就是谁 def tell(self): print(\"my name is %s,age %s,hair is %s\"%(self.name,self.age,self.hair)) pass#类名() 表示实例化一个对象p = Person(\"js\",18)p.tell()p1 = Person(\"LY\",14)p1.tell() 4、访问原来的属性可以通过Person.来进行访问 #访问原来属性：print(Person.name)print(Person.age)Person.tell(p1) #self可以传入实例 注意：可以看出，类中与实例中属性不同。当调用传入参数中没有的属性时，对调用类属性 5、析构函数当实例被回收时自动调用 class Person: def __init__(self,name,age): self.name = name self.age = age #析构函数，当实例被回收时自动调用 def __del__(self): print(\"析构函数调用\") def tell(self): print(\"mtname is %s,age %s\"%(self.name,self.age))p = Person(\"sj\",18)p.tell()\"\"\"当程序结束时，析构函数就会调用\"\"\" 6、使用私有属性、私有方法通过__ 就可以设置私有属性和私有方法：例如__namedef __setName(self,name): 设置了私有之后，只能通过公有来调用 class Person: def __init__(self,name,age): #加两个下划线表示私有属性，不能直接被外部访问 self.__name = name self.__age = age def getAge(self): return self.__age def setAge(self,age): self.__age = age #可以设置私有方法，同理，只能通过公用方法调用 def __setName(self,name): self.__name = name def setNamePass(self): pwd = 123 res = int(input(\"请输入密码：\")) if res == pwd: self.__setName(\"haha修改成功\") else: print(\"pass word error\") def tell(self): print(\"mtname is %s,age %s\"%(self.__name,self.__age))p = Person(\"sj\",18)p.tell()print(p.getAge())p.setAge(10)p.tell() #可以看出修改成功p.setNamePass()p.tell() 7、继承、重写、拓展继承，括号内填写父类,这样就能够拥有父类的方法属性，减少重复工作 #继承，括号内填写父类,如class MtList(list): pass 在继承中，经常引用其他文件中的类通过 if name == ‘main‘ 可以只导入功能，在继承时十分常用 一个小练习如下： from day15.面向对象 import Person#通过 if __name__ == '__main__' 可以只导入功能，p = Person(\"LS\",18)p.tell()class Basterd(Person): #方法拓展，在保留父类方法时拓展 def __init__(self,name,age,badhobby): super().__init__(name,age) self.badhobby = badhobby #方法重写，完全覆盖父类方法 def tell(self): print(\"我叫%s，age %s，我爱%s\"%(self.name,self.age,self.badhobby))\"\"\"建立一个坏弹类，坏蛋是一个人，坏蛋有他特殊的属性与发方法\"\"\"if __name__ == '__main__': p = Basterd(\"ly\",18,\"打架\") p.tell() 其中，init()用到了拓展，tell()则是直接覆盖了 8、小练习class Clip: def __init__(self,bullet): self.bullet = bullet class Gun: def __init__(self,clip): self.clip = clip def fier(self,n): if self.clip.bullet &gt; n: self.clip.bullet -= n print(\"开枪；还剩%s发子弹\"%(self.clip.bullet)) for i in range(n): print(\"tu~\") else: print(\"子弹不够啦，上子弹啊！\") class Person: def __init__(self,gun): self.gun = gun def fill(self,n): self.gun.clip.bullet += n print(\"上弹成功，还有%s发\"%(self.gun.clip.bullet)) from day15.clip import *from day15.gun import *from day15.Person import *c = Clip(10)g = Gun(c)p = Person(g)for i in range(4): p.gun.fier(3)p.fill(5)for i in range(4): p.gun.fier(3)\"\"\"运行效果开枪；还剩7发子弹tu~tu~tu~开枪；还剩4发子弹tu~tu~tu~开枪；还剩1发子弹\"\"\"","permalink":"http://jj1m8.github.io/2020/04/03/day15%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day14：time模块、异常处理、装饰器、主程序调用","date":"2020/04/03","text":"一、time模块import time使用前记得import 1、time.time 时间戳从1970年1月1日0.0开始到现在过去了多少秒 #time.time 时间戳res = time.time()#从1970年1月1日0.0开始到现在过去了多少秒print(\"timeis: %s\"%res)#一般用于计算程序运行时间for i in range(100000): passresl = time.time()run = resl - resprint(\"runTimeis: %s\"%run) 2、time.localtime显示时间，有参数时显示1970-1-1零点过去两分钟（东八区会多八小时 #time.localtimeres = time.localtime()print(res)res = time.localtime(120)#1970-1-1零点过去两分钟（东八区会多八小时print(res) 3、time.gmtime世界协调时，会自动减去8小时#time.gmtimevar = time.gmtime() #utf世界协调时，会自动减去8小时print(var) 4、mktime 结构化一个时间戳#mktime 结构化一个时间戳res = time.mktime(var)print(res) 5、time.ctime 返回英式时间 time.strtime 时间格式化#time.ctime 返回英式时间 time.strtime 时间格式化res = time.ctime()print(res)res = time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime())print(res) #2020-03-11 10:39:31 6、time.strptime 结构化时间#time.strptime 结构化时间var = time.strptime(res,\"%Y-%m-%d %X\")print(var) 7、time.sleep 休眠#time.sleepwhile True: print(\"yeyeyeye\") time.sleep(1) 二、异常处理异常处理try: 可能发生错误的语句except 异常类型: 如果发生异常 那么执行此处的语句 目的：当程序中出现异常后也能继续运行 \"\"\"异常处理try: 可能发生错误的语句except 异常类型: 如果发生异常 那么执行此处的语句当程序中出现异常后也能继续运行\"\"\"try: print(1/0)except ZeroDivisionError as e: print(e) #division by zero print(\"除数不能为0\")L = [1,2,3]try: print(L[6])except IndexError as e: print(e) #list index out of rangeprint(\"1\"+\"1\") 异常处理try: 可能发生错误的语句except 异常类型: 如果发生异常 那么执行此处的语句else: 没发生异常执行的语句 \"\"\"异常处理try: 可能发生错误的语句except 异常类型: 如果发生异常 那么执行此处的语句else: 没发生异常执行的语句\"\"\"L = [1,2,3]try: print(L[2])except IndexError as e: print(e) #list index out of rangeelse: print(\"写对了。。。\") try: 可能异常的语句except 异常信息 as e: 异常处理finally: 无论如何都会运行的语句 文件操作中经常使用finally来关闭文件 \"\"\"try: 可能异常的语句except 异常信息 as e: 异常处理finally: 无论如何都会运行的语句 文件操作中经常使用finally来关闭文件\"\"\"L = [1,2,3]try: print(L[2])except IndexError as e: print(e) #list index out of rangefinally: print(\"我一定运行\") 所有异常都继承于一个BaseException如果在补货时不知道是什么错，可以except BaseException:一般写Exception就可以了 注意：1，如果已经捕获到异常后，就不会再捕获了2，可以捕获嵌套错误 \"\"\"所有异常都继承于一个BaseException如果在补货时不知道是什么错，可以except BaseException:一般写Exception就可以了注意：1，如果已经捕获到异常后，就不会再捕获了2，可以捕获嵌套错误如try: main()except BaseException: pass\"\"\"L = [1,2,3]try: print(L[6])except Exception as e: print(e) #list index out of rangefinally: print(\"我一定运行\") 三、装饰器1、装饰器：在不改变原函数的情况下，给这个函数增加一个新功能写接口时会用到实现如下使用装饰器后，调用func() == 调用inner() def outer(fn): def inner(): start = time.time() fn() run = time.time() - start print(run) return inner@outer #装饰器 是语法糖def func(): for i in range(100000): pass print(\"hello\")func() #使用装饰器后，调用func() == 调用inner() 运行原理如下： import timedef foo(fn): start = time.time() fn() run = time.time() - start print(run)def func(): for i in range(100000): pass print(\"hello\")foo(func) 2、当被装饰的函数带参数时#当被装饰的函数带参数时：def outer(fn): #接收被装饰的函数 def inner(*args,**kwargs): #接收被装饰的函数的形参 start = time.time() fn(*args,**kwargs) run = time.time() - start print(run) return inner@outerdef func(name,user,pwd): for i in range(100000): pass print(user+\"说 得了吧\"+name,pwd)func(\"jack\",\"rose\",1234) 3、当装饰器需要有参数时#当装饰器需要有参数时def outer(num): #接收装饰器的参数 def middle(fn): #接收被装饰的函数 def inner(*args,**kwargs): #接收被装饰的函数的形参 start = time.time() for i in range(num): fn(*args,**kwargs) run = time.time() - start print(run) return inner return middle@outer(5)def func(name,user,pwd): for i in range(100000): pass print(user+\"说 得了吧\"+name,pwd)func(\"jack\",\"rose\",1234) 四、主程序调用在py中，可以通过import与from来进行调用，如果想要实现只能在本文件中能实现的功能，不让调用的文件使用的话，可以使用主程序调用 print(\"1111111111\")if __name__ == '__main__': #加入这句话可以让这下面的语句只能在本文件中调用 print(\"hello\") import与from调用的区别为：from导入要从当前打开的路径开始 import 主程序判断#输出 1111111111 而没有 hello #导入还可以通过from导入，不过要从当前打开的路径开始from day14.主程序判断 import *# import *比较少用，会导致明明覆盖问题 可以看出，通过if语句判断后，其他文件调用时不会打印hello 五、面试题#面试题def f(x,l=[]): for i in range(x): l.append(i * i) print(id(l)) print(l)f(2)f(3,[3,2,1])f(3)f(3,[1,2])\"\"\"[0, 1][3, 2, 1, 0, 1, 4][0, 1, 0, 1, 4][1, 2, 0, 1, 4]\"\"\" 可以注意到，当默认参数为空列表的时候，python会开辟一个内存，之后每次当为空列表（即不传值时就会继续使用这个地址(id相同)。所以尽量不要定义空列表的默认参数简单说就是传递一个参数和传递两个参数的内存地址不一样","permalink":"http://jj1m8.github.io/2020/04/03/day14%EF%BC%9Atime%E6%A8%A1%E5%9D%97%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E3%80%81%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day13：os模块、os.path方法、递归函数","date":"2020/04/03","text":"一、os模块os是系统自带的模块通过os.来进行使用 1、os.name查询系统名 res = os.nameprint(res) 2、os.system调用系统命令os.system(\"ipconfig\") #使用在cmd中可以使用的命令都可以用os.system(\"notepad\") 3、os.getcwd()返回当前工作路径绝对路径：从盘服开始的相对路径：相对于当前工作路径写出的路径 ../上一级目录 res = os.getcwd()print(res) 4、os.listdir（） 返回指定目录下的所有文件与文件夹res = os.listdir(\"G:\\project\\pyProject\\day13\")print(res)res = os.listdir() #\"../\" 则返回上一级目录print(res) 5、os.remove 删除指定文件os.remove(\"../txt\") 6、os.mkdir 创建目录 os.makedirs 创建多级目录os.mkdir(\"../day14\")os.makedirs(\"../day14/day15/day16\") 7、os.rmdir 删除指定目录os.rmdir(\"../day14/day15/day16\") #删除了day16 8、os.removedirs 删除路劲中所有空文件os.removedirs(\"../day14/day15\")\"\"\"如果文件夹中有文件不为空，则删除不掉，使用os不行使用shutil可以，shutil.rmtree(\"../day14\")可以直接删除day14及其内部的东西\"\"\" 9、os.chdir 更换工作路径os.chdir(\"../day13\")res = os.getcwd()print(res) 10、os.rename 更名,注意两个参数都是路径os.rename(\"../day10/a.py\",\"../day10/b.py\")#如果不写路径就会改到其他文件夹去导致文件位置改变 11、#os.walk 遍历目录下所有目录与文件第一个参数：返回一个路径第二个参数：这个路径下所有目录第三个参数：这个路径下所有文件 res = os.walk(\"../\")for var in res: #res是生成器 print(var) 二、os.path方法1、os.path.abspath将相对路径转化为绝对路径#-*- coding: utf-8 -*-import os#os.path.abspath#将相对路径转化为绝对路径res = os.path.abspath(\"../day10/b.py\")#G:\\project\\pyProject\\day10\\b\\pyprint(res)\"\"\"在window中，文件夹使用\\来显示，这样可能是转义字符，要用“\\\\”最好写成//之后还会遇到这样转换操作 \"\".replace(\"\\\\\",\"/\")\"\"\" 2、os.path.split 分割目录和文件名#os.path.split 分割目录和文件名res = os.path.split(\"G:\\project\\pyProject\\day10/b.py\")print(res) #('G:\\\\project\\\\pyProject\\\\day10', 'b.py') 3、os.path.join 拼接目录和文件名#os.path.join 拼接目录和文件名res = os.path.join(\"G:\\\\project\\\\pyProject\\\\day10\",\"b.py\")print(res) #G;\\project\\pyProject\\day10\\b.py 4、os.path.exists 判断一个路径是否存在#os.path.exists 判断一个路径是否存在res = os.path.exists(\"G:\\\\project\\\\pyProject\\\\day10\\\\b.py\")print(res) 5、os.path.isfile 判断是否是一个文件res = os.path.isfile(\"G:\\project\\pyProject\\day10\\\\b.py\")print(res) 6、os.path.isdir 判断是否是一个目录#os.path.isdir 判断是否是一个目录res = os.path.isdir(\"G:/project/pyProject/day10\")print(res) 7、os.path.getsize 获取一个文件大小#os.path.getsize 获取一个文件大小res = os.path.getsize(\"G:\\project\\pyProject\\day10\\optionOfDict.py\")print(res) #1663字节 三、递归函数递归，自身调用自身 最重要的是找到一个出口好处：精简程序执行中的重复调用例如： 求阶乘#求阶层 5*4*3*2*1def func(n): if n == 1: return 1 else: return func(n-1) * n\"\"\"res = func(4)*5 -&gt; func(3)*4*5 -&gt; func(2)*3*4*5 -&gt; func(1)*2*3*4*5res = 1*2*3*4*5注意每调用一次函数就会增加一层栈帧 没计算一次就会少一层栈帧栈帧超过999就会报错\"\"\"res = func(5) #999报错，超出了递归的最大范围print(res) 为了防止栈溢出报错，我们需要引用尾递归方法遗憾的是python目前没有对尾递归进行优化 #尾递归def fact(n): return fact_iter(n,1)def fact_iter(num,product): if num == 1: return product else: return fact_iter(num-1,product*num)# fact_iter(4,5)# fact_iter(3,20)# fact_iter(2.60)# fact_iter(1,120)# product = 120print(fact(5)) 计算斐波那契额数列1、1、2、3、5、8、13、21、34、、、n def funcFBNQ(n): if n==1 or n==2: return 1 else: return funcFBNQ(n-2) + funcFBNQ(n-1)#这个数为前两个数加前一个数print(funcFBNQ(10)) 汉诺塔游戏def funcHNT(n,a,b,c): if n==1: print(a,\"--&gt;\",c) else: funcHNT(n-1,a,c,b) print(a,\"--&gt;\",c) funcHNT(n-1,b,a,c)funcHNT(3,\"a\",\"b\",\"c\") 四、超市小练习#-*- coding: utf-8 -*-\"shop_list = [[\"健力宝\",5.6],[\"加多宝\",10],[\"QQ星\",50],[\"动脉\",100]]buy_list = []prise = 0print(\"====================宝昌面包=====================\")for num,shop in enumerate(shop_list): print(num,shop[0],shop[1])print(\"按0退出系统\")print(\"=================================================\")salary = int(input(\"请输入你有多少salary：\"))if salary &gt; 0: while True: buyNum = int(input(\"请输入你要买的商品：\")) if buyNum == 0: break if salary &gt;= shop_list[buyNum-1][1]: print(\"购买成功\") salary -= shop_list[buyNum-1][1] prise += shop_list[buyNum-1][1] buy_list.append(shop_list[buyNum-1][0]) print(\"感谢购买，消费%s，余额%s\" %(shop_list[buyNum-1][1],salary)) else: print(\"无法购买，穷逼\")else: print(\"清先充钱\")print(\"购买清单为：\")for var in buy_list: print(var)print(\"感谢使用\") 路径中有中文报错时，在文件头加上即可 #-- coding: utf-8 --","permalink":"http://jj1m8.github.io/2020/04/03/day13%EF%BC%9Aos%E6%A8%A1%E5%9D%97%E3%80%81os-path%E6%96%B9%E6%B3%95%E3%80%81%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day12：元祖的操作、字典的操作、文件操作、pickle模块","date":"2020/04/03","text":"一、元祖遍历使用for循环遍历t = (1,2,3,4,5)for var in t: print(var)i = 0t = ((1,2),(3,4),(5,6))for var in t: for val in var: print(val) 使用while循环遍历while i &lt; len(t): print(t[i]) i = i+1 元祖的+、*+两个元祖合并，生成新元祖*一个元祖重复输出，生成新元祖 t = (1,2,3,4,5)t1 = (6,7)t2 = t + t1print(t2) #元祖不能改变t2 = t * 3print(t2) 二、元祖常用方法由于元祖不能改变，所以其方法也少 1、查询结果 index输入下标，返回元素 #查询结果res = t.index(2)print(res) 2、查询数量 count查询输入元素的出现次数 #查询数量res = t.count(4)print(res) 3、元祖推导式产生生成器，可以使用for循环遍历 t = (1,2,3,4,5)res = (var**2 for var in t)print(res) #generator产生生成器for var in res: #可以通过for、next遍历 print(var) 三、字典的操作字典的创建dict1 = &#123;\"a\":1,\"b\":2,\"c\":3&#125;print(dict1,type(dict1))dict2 = dict([[\"a\",1],[\"b\",2]])#通过转换实现，少用print(dict2,type(dict2))dict3 = dict(&#123;\"a\":1,\"b\":2,\"c\":3&#125;)#转换，把字典转换成字典print(dict3,type(dict3))dict4 = dict(a=1, b=2, c=3)print(dict4,type(dict4))dict5 = dict(zip((\"a\",\"b\",\"e\",\"c\"),(1,2,3)))#长度不同，以最短的为主print(dict5,type(dict5)) 字典的遍历for key,value in dict5.items(): print(key,value) 四、字典的内置方法1、items 字典转化为类似元祖的方式2、keys 将字典所有key组合成一个序列3、values 将字典所有value组合成一个序列**4、复制 copycopy是浅拷贝，当二级字典发生变化是，拷贝的也会改变 #复制copydict1 = &#123;\"1\":&#123;\"a\":2,\"b\":3,\"c\":4&#125;&#125;#复制copydict2 = dict1.copy()print(dict2)dict1[\"1\"][\"d\"] = 1 #字典添加print(dict2) #在二级字典里的会随之改变print(dict1) 5、get 根据key，返回value好处是没有的key，不会报错，而是返回none #get 根据key，获取valuedict1 = &#123;\"a\":1,\"b\":2,\"c\":3&#125;#res = dict1[1] #如果这里搜索没有的key，报错导致程序结束res = dict1.get(\"ab\")print(res) #则返回none 6、pop 移除指定元素，返回键对应值，popitem() 删除最后一个，字典为空，则报错#pop 移除指定元素，返回键对应值res = dict1.pop(\"a\",\"key is no in here\")#加上默认值则可以不用报错print(res)print(dict1)#popitem() 删除最后一个，字典为空，则报错dict1 = &#123;\"a\":1,\"b\":2,\"c\":3&#125;res = dict1.popitem()print(res)print(dict1) 7、setdefault 添加一个键，如果存在则不进行操作#setdefault 添加一个键，如果存在则不进行操作dict1.setdefault(\"cc\",7)print(dict1) 8、update 没有的键值会添加，已有的会进行更新#updatedict1.update(&#123;\"jj\":\"hh\"&#125;)print(dict1)dict2 = &#123;\"d\":5,\"e\":5,\"ff\":7&#125;dict1.update(dict2)print(dict1) #没有的键值会添加，已有的会进行更新 五、文件操作open(file_path,mode)mode 权限： w(write 写，如果没有这个人间会自动创建一个）f = open(\"user.txt\",\"w\")f.write(\"www.python.com\")f.close() #写完之后记得关闭 r(read 读：read读取全部、readline读取一行、readlines以行为单位全部读取f = open(\"user.txt\",\"r\")#content = f.read()#content = f.readline()content = f.readlines() #最常用，以行为单位全部读取print(content)f.close() a(append 追加，如果没有这个文件则创建一个，如果有则在文件末尾追加)f = open(\"user.txt\",\"a\")f.write(\"hello\")f.close() w+ 读写权限 会覆盖之前内容（先清空再覆盖r+ 读写 （不会先清空再覆盖，即没有创建新文件的权限a+ 读写 （不会清除文件，而是在文件尾部追加）f = open(\"user.txt\",\"w+\")f.write(\"hello world\")f.seek(0,0) #写操作之后光标会在最末端，导致读取从最末端开始，seek移动光标content = f.read()print(content)f.close()f = open(\"user.txt\",\"r+\")f.write(\"world\")f.seek(0,0) #写操作之后光标会在最末端，导致读取从最末端开始，seek移动光标content = f.read()print(content)f.close()f = open(\"user.txt\",\"a+\")f.write(\"world\")f.seek(0,0) #写操作之后光标会在最末端，导致读取从最末端开始，seek移动光标content = f.read()print(content)f.close()\"\"\"输出结果为hello worldworld worldworld worldworld\"\"\" wb 二进制写rb 二进制读ab 二进制追加写#二进制模式一般在计算机交互时使用f = open(\"user.txt\",\"wb\")f.write(\"我好好学习\".encode(\"utf-8\"))f.close()f = open(\"user.txt\",\"rb\")content = f.read().decode(\"utf-8\")print(content)f.close()#通过使用errors参数可以不报错，但是会是乱码f = open(\"user.txt\",\"w\",encoding=\"utf-8\")# binary mode doesn't take an encoding argumentf.write(\"我好好学习\")f.close()f = open(\"user.txt\",\"r\",encoding=\"gbk\",errors=\"ignore\")content = f.read()print(content)f.close() 为什么要close在write的时候，是写到缓冲区中，而不是直接写进文件，并且，文件不去close会导致文件没有保存，既没有生成 刷新缓冲区的方式：（即把缓冲区的内容写入文件中） 1、缓冲区呗占满了 2、关闭文件时自动刷新 3、程序运行结束 4、手动刷新缓冲区 flush（） with语法，不用手动关闭文件，执行结束，自动关闭文件#with语法，不用手动关闭文件，执行结束，自动关闭文件with open(\"user.txt\",\"w\",encoding=\"utf-8\") as f: f.write(\"这是一个测试\")with open(\"user.txt\",\"r\",encoding=\"utf-8\") as f: content = f.read() print(content) 六、pickle模块使用前需要导入 import pickle四个函数：dump （文件用）loaddumps （列表等使用）loads通过使用pickle模块可以方便二进制的数据传输解码 import pickle #是一个模块需要导入L = [1,2,3,4,5]res = pickle.dumps(L)#当网络发送时，转换成二进制发送print(res)con = pickle.loads(res)print(con) #接收时解码#dump是用于文件操作的with open(\"user.txt\",\"wb\") as f: str = \"这是一个测试\" pickle.dump(str,f)with open(\"user.txt\",\"rb\") as f: res = pickle.load(f) print(res)","permalink":"http://jj1m8.github.io/2020/04/03/day12%EF%BC%9A%E5%85%83%E7%A5%96%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%81%E5%AD%97%E5%85%B8%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%81pickle%E6%A8%A1%E5%9D%97/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 11：列表推导式与深浅拷贝","date":"2020/04/03","text":"1、列表推导式通过使用列表推导式，用简洁的代码实现复杂功能例如：打印10与10各个数字的组合 res = [(x,y) for x in range(10) for y in range(10)]print(res) 打印偶数奇数的组合 res = [(x,y) for x in range(10) if x%2==0 for y in range(10) if y%2==1]print(res) 打印ABC与123的组合 res = [x+y for x in \"ABC\" for y in \"123\"]print(res)#会先循环先写的 练习：给一列表M打印要求数据 #给一列表M打印要求数据M = [[1,2,3],[4,5,6],[7,8,9]]#求 1 4 7res = [var[0] for var in M]print(res)#求1 5 9res = [M[i][i] for i in range(len(M))]print(res) 给一列表，求每一元素的长度的列表 #涉及到每一个元素就使用for var in LL = [\"continue\",\"else\",\"if\",\"break\",\"pass\",\"def\"]#res = [len(L[i]) for i in range(len(L))]res = [len(var) for var in L]print(res) 2、深浅拷贝1、赋值是同一内存地址，b指向a的内存地址，当a的值发生改变的时候，b也会变 a = [1,2,3,4,[5,6]]b = aa.append(7)print(b) 2、浅拷贝，拷贝第一层，第二层还是拷贝地址 import copya = [1,2,3,4,[5,6]]c = copy.copy(a)a[4].append(7)a.append(8)print(c) 3、深拷贝，拷贝所有数据，全部新开辟一块内存，a变，d不会有变化 a = [1,2,3,4,[5,6]]d = copy.deepcopy(a)a[4].append(7)a.append(8)print(d) 以上三条输出分别为：[1, 2, 3, 4, [5, 6], 7][1, 2, 3, 4, [5, 6, 7]][1, 2, 3, 4, [5, 6]]","permalink":"http://jj1m8.github.io/2020/04/03/day-11%EF%BC%9A%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F%E4%B8%8E%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 10:列表的相关操作","date":"2020/04/03","text":"列表的相关操作 \"\"\"列表的操作\"\"\"#重复输出#print(L1*3)L1 = [\"Python\",\"PHPPHP\",\"H5EE\",\"Js\",\"Java\"]print(L1[0][1:5]) #[1:5]不会取到5print(L1[1][0:3])print(L1[2][-2:])#in not in成员判断L2 = \"Python\"print(L2 in L1)#遍历for val in L1: print(val)i = 0while i &lt;len(L1): print(L1[i]) i+=1#append 追加，末尾L1.append(\"C++\")for val in L1: print(val)#insert 插入，在指定位置L1.insert(1,\"haha\")for val in L1: print(val)#extend 扩展，将L2 = [\"123\",\"456\"]L1.append(L2)print(L1)L1.extend(L2)print(L1)#pop 传递待删除的元素的索引值，并且发返回被删除的元素#不传参数就会删除最后一个值，res = L1.pop(1)print(L1,res)#remove 删除指定的元素，如果有重复， 默认删除第一个L1.remove(\"Python\")print(L1)#count 查询某元素的出现次数res = L1.count(\"123\")print(res)#index 查询元素的索引 (\"\",5) 5值起始位置res = L1.index([\"123\",\"456\"])print(res)print(L1.pop(res),L1)#reverse 列表中的元素从右到左重新存放一遍L1.reverse()print(L1)#sort 对列表中的数据排序整理L1.sort()print(L1)L1.sort(reverse = True)#倒序排print(L1)L1.sort(key=len) #按长度print(L1)L = [3,5,8,-3,-1]L.sort(key=abs) #按绝对值print(L)#如果在sort想保留原数据#clear 清空列表L.clear()print(L) #空列表#copy 复制res = L1.copy()print(res)L = [1,2,3,4,[5,6]]#浅拷贝，只拷贝了最外层，内层改变是会一起改变的res = L.copy()print(res)L[4].append(7)print(res) #会随着改变，内层拷贝不过来，会指向原列表的二级列表（地址）","permalink":"http://jj1m8.github.io/2020/04/03/day-10-%E5%88%97%E8%A1%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 9：format操作与数字相关方法","date":"2020/04/03","text":"一、format 格式化字符format 格式化字符 语法：通过{}和：来代替%注意：format可以接受无限个参数，位置也可以不按顺序 参数也可以不使用也可以使用多次，2.6前不能为{}，2.7后可以为空 str1 = \"&#123;&#125; say hello to &#123;&#125;\"str2 = str1.format(\"jack\",\"rose\")print(str2)str1 = \"&#123;1&#125; say hello to &#123;0&#125;\" #可以通过索引改变顺序str2 = str1.format(\"jack\",\"rose\")print(str2)str1 = \"&#123;0[1]&#125; say hello to &#123;0[1]&#125;\" #可以通过索引改变顺序str2 = str1.format([\"jack\",\"rose\"])print(str2)str1 = \"&#123;name&#125; is &#123;age&#125; years old\"str2 = str1.format(name = \"jack\", age = \"19\")print(str2)#format在网页爬虫中的应用ur1 = \"https://study.163.com/category/480000003121024#/?p=&#123;page&#125;\"start_page = 1while start_page&lt;10: ur1.format(page=start_page) start_page += 1\"\"\"^ 居中&lt; 左对齐&gt; 右对齐(都比较少用)\"\"\"str1 = \"this\"str2 = \"&#123;:@^10&#125;\".format(str1)print(str2)str2 = \"&#123;:@&lt;20&#125;\".format(str1)print(str2)#调整精度str1 = \"&#123;:.3f&#125;\".format(3.141592)print(str1)str1 = \"%.2f\"%(1.2345)print(str1)#进制转换str1 = \"&#123;:b&#125;\".format(16)print(str1)str1 = \"&#123;:d&#125;\".format(16)print(str1)str1 = \"&#123;:o&#125;\".format(16)print(str1)str1 = \"&#123;:x&#125;\".format(16)print(str1)#预留符str1 = \"&#123;:,&#125;\".format(123415153452)#123,415,153,452print(str1)#locals 打印所有元素name = \"xiaoming\"def func(): name = \"xiaoming\" age = \"18\"print(locals()) 二、数学相关方法abs() 绝对值sum() 求和max() 求最大值min() 求最小值pow(2,3,5) 幂运算 第三个参数是幂运算的结果对它取余round() 对一个数值进行四舍五入range(1,10,2) 1到10，间隔2（负号指反过来） num = [1,2,7,11,5]i = 0res = 0while i &lt; len(num): if res &lt; num[i]: res = num[i] i+=1print(res)res = 0for val in num: #通过for循环进行遍历更加方便 if val&gt;res: res = valprint(res) 三、字符相关\"\"\"chr(32) 把ASCII码换成字符ord(\"A\") 把字符转换成ASCII码eval() 把字符串去掉，换成数\"\"\"num = 1str1 = \"num+1\"print(eval(str1)) #2","permalink":"http://jj1m8.github.io/2020/04/03/day-9%EF%BC%9Aformat%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 8:字符串相关方法","date":"2020/04/03","text":"字符串内置方法：dir（） 查询这个类型的数据有什么操作方法 通过ctrl+鼠标键可以查看使用方法 str1 = \"hello world\"print(dir(str1))#capitalize 整个字符串的首字母大写str2 = str1.capitalize()print(str2)#title 每个单词的首字母大写str3 = str1.title()print(str3)#upper 所有字母大写str4 = str1.upper()print(str4)#lower 所有字母小写str5 = str4.lower()print(str5)#swapcase 大小写互换str6 = str5.swapcase()print(str6)#count 查询字符在字符串出现的次数,可以自定义查找位置res = str1.count(\"o\",0,5)print(res)#find 查找某字符出现的位置,默认只查询一个res = str1.find(\"o\")print(res)#startswith 判断是否以某个字符串开头，可以加区间res = str1.startswith(\"o\",4)print(res)#endswith 判断是否以某一个字符串借位res = str1.endswith(\"d\",4)print(res)#isupper 判断是否都是大写字母#islowerres = str1.isupper()print(res)res = str1.islower()print(res)#isalnum 判断字符串是否都是由数值，字母，汉字组成str1 = \"this中123\"res = str1.isalnum()print(res)#isdigit 判断字符串是否由十进制数值组成(这个比较常用)#isdecimal 判断是否由数值组成de1字符串#isnumeric 判断是否由数字组成的字符串str1 = \"123\"res = str1.isdigit()print(res)res = str1.isdecimal()print(res)res = str1.isnumeric()print(res)\"\"\"isdigit()True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字Error: 无isdecimal()True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字Error: byte数字（单字节）isnumeric()True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节）\"\"\"#isspace 判断字符串是否是由空白符组成str1 = \"\\n\"res = str1.isspace()print(res)#istitle 判断是否每一个字母首字母都大写str1 = \"Hello World\"res = str1.istitle()print(res)#len 计算字符串的长度res = len(str1)print(res)#split 按照指定的字符进行切分，默认按照空格str2 = str1.split(\" \")print(str2)#splitlines 按照换行进行泄愤str1 = \"this is \\n a \\n test\"str2 = str1.splitlines()print(str2)#join 字符串拼接str1 = \"@\"str2 = \"this\"str3 = str1.join(str2) #t@h@i@sprint(str3)str1 = \"@\"str2 = [\"this\",\"is\",\"a\",\"test\"]str3 = str1.join(str2) #this@is@a@testprint(str3)#zfill 填充字符串str1 = \"this\"str2 = str1.zfill(20)#0000000000000000thisprint(str2)#center 用指定字符填充，然后字符串居中str1 = \"this\"str2 = str1.center(10,\"A\") #AAAthisAAAprint(str2)#rjuststr1 = \"this\"str2 = str1.rjust(10,\"@\") #@@@@@@thisprint(str2)#ljuststr1 = \"this\"str2 = str1.ljust(10,\"@\") #this@@@@@@print(str2)#strip 取出两头某之丰富str1 = \"\\nthis\\n\"str2 = str1.strip()print(str2)#rstrip 从右边去掉某个字符str1 = \"\\nthis\\n\"str2 = str1.rstrip()print(str2)#lstrip 从右边去掉某个字符str1 = \"\\nthis\\n\"str2 = str1.lstrip()print(str2)#maketrans 和 translatestr1 = \"this is test\"str2 = str1.maketrans(\"t\",\"T\") #制作映射表print(str2)str3 = str1.translate(str2) #传入映射表print(str3)#replace 替换 (更加好用)str2 = str1.replace(\"t\",\"T\",2)print(str2)","permalink":"http://jj1m8.github.io/2020/04/03/day-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 7：函数，字符串切片","date":"2020/04/03","text":"一、不定长参数全局变量：顶格写的变量，在任何地方都可以使用 局部变量： 在代码组中定义，只能在代码组中使用 #函数定义def opration(a,b,c,d): sum1 = a + b + c + d print(sum1)opration(1,2,3,4)#使用容器作为参数def opration(*args): sum1 = 0 for var in args: sum1+=var return sum1res = opration(1,2,3,4)print(res)# * 垃圾回收站，他不能接收关键字参数,不能接收关键字参数#带* 的参数要放在形参的最后面def opration(a,b,c,*d): print(a) print(b) print(c) print(d)opration(1,2,3,4,5,6,7)# **接收不定长关键字参数,只能放在最后def opration(a,b,c,d,*args,**kwargs): print(a,b,c,d) print(args) print(kwargs)opration(1,2,3,4,5,6,7,A = 9,B = 0) 二、函数闭包函数闭包：内部函数调用外部函数的变量（非全局变量， 则称内部函数为闭包 即调用一个函数，返回一个新的函数来，称为闭包 def func(): num = 1 def func1(): num=2 print(num) print(num) func1() print(num)func() #1,2,1#先return inner这个函数，之后res代表inner，而num1传入了20def outer(num1): def inner(num2): return num1 + num2 return innerres = outer(20)result = res(10)print(result)#在使用闭包的时候，在内部没有引用的外部变量才可以#而内部有使用时，代码会运行内部的变量，而导致没定义的报错# def outer(a):# def inner():# a = a+1# return a# return inner# res = outer(1)# result = res()# print(result)def outer(a): def inner(): a[0] = a[0]+1 #使用容器后，并没有定义a，而是对a的一个取值 return a return innerres = outer([1])result = res()print(result) 三、字符串和列表的切片[开始索引:结束索引:间隔] 切片操作(结束索引取不到) 不加结束索引代表从开始索引取到最后 间隔缺省则是1 str1 = \"停车坐爱枫林晚，霜叶红于二月花\"print(str1[-3],str1[-2],str1[-1])print(str1[-3:])print(str1[::2])print(str1[4:0:-1])print(str1[::-1 ])var = range(100)print(var[25:31])print(var[70:83:3])print(var[90:84:-1])print(var[99:69:-5])print(var[-10:-30:-2])print(var[90:200]) #a取到90到99print(var[150:200])#取出来为空。","permalink":"http://jj1m8.github.io/2020/04/03/day-7%EF%BC%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 6：循环","date":"2020/04/03","text":"一、while循环while True：死循环，只能使用break break： 退出当前循环 continue：继续下一轮循环 pass 在循环体或者函数体空时防止报错 import random #引入随机数luck_num = random.randint(10,99)luck_num_g = luck_num % 10luck_num_s = luck_num //10while True: buy_num = int(input(\"请输入一个两位数：\")) if buy_num == luck_num: print(\"一等奖\") break elif buy_num % 10 == luck_num_s and buy_num //10 == luck_num_g: print(\"二等奖\") break else: print(\"遗憾,没中奖\") 二、使用while打印乘法表 正三角 i = 1while i &lt; 10: j = 1 while j &lt;= i: print(j,\"x\",i,\"=\",i*j,end=\" \") j += 1 print() i += 1 倒三角 i = 9while i &gt; 0: j = 1 while j &lt;= i: print(j,\"*\",i,\"=\",i*j,end=\" \") j += 1 print() i -= 1 向左三角 while i &lt; 10: count = 0 while count&lt;k: print(end=\" \") count+=1 k-=1 j = 1 while j &lt;= i: print(\"%s*%s=%s\"%(j,i,i*j),end=\"\\t\") j += 1 print() i += 1 向左倒三角 i = 9while i &gt;0: k = 9 while k &gt; i: print(end=\" \") k -= 1 j = 1 while j &lt;= i: print(\"%s*%s=%s\"%(j,i,i*j),end=\"\\t\") j += 1 print() i -= 1 三、使用for循环常在遍历时候使用， 在字典中取出键值，但可以用var.values()获得键值,用var.items()得到它本身 var = \"今年过年不收礼啊，\"for val in var: print(val)#for循环嵌套var = [\"python\",\"hello\",\"java\",\"c\"]for val in var: print(val) for res in val: print(res)var = &#123;\"a\":1,\"b\":2,\"c\":3&#125;for val in var.items(): print(val) #在二级列表的使用中，可以使用abc这样的获得相应值，要求长度相同 var = [[1,2,3],[4,5,6],[7,8,9]]for a,b,c in var: print(a,b,c)range(a,b) a为起始，b为最大值-1，(如果没有a那么就是从0开始 通过for循环打印乘法表for i in range(1,10): for j in range(1,i+1): print(\"%sx%s=%s\"%(j,i,i*j),end=\"\\t\") print()for i in range(1, 10): for j in range(i, 10): print(\"%sx%s=%s\" % (i, j, i * j), end=\"\\t\") print()for i in range(1, 10): for k in range(1, 10 - i): print(end=\" \") for j in range(1, i + 1): print(\"%sx%s=%s\" % (j, i, i * j), end=\"\\t\") print()","permalink":"http://jj1m8.github.io/2020/04/03/day-6%EF%BC%9A%E5%BE%AA%E7%8E%AF/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 5：小练习与分支结构","date":"2020/04/03","text":"一、身份检测is 是is not 不是# var = \"man\"# val = \"man\"# res = var is not val# print(res) 二、位运算 &amp; 按位于| 按位或^ 按位或~ 按位取反&lt;&lt; 左移 右移 三、分支结构流程控制流程：执行代码的顺序顺序结构，分支结构，循环结构 单向分支 :if 条件语句： 功能 … 双向分支：if 条件1： 功能1else： 功能2 多向分支：if 条件1： 功能1elif 条件2： 功能2elif 条件3： 功能3… 巢状分支:（嵌套）if 条件1： if 条件2： 功能2 else: 功能3else 功能4 四、内容输入name = input()name = input(\"请输入你的用户名：\")num = int(input(\"请输入你的年龄：\")) 得到int型的输入name = input(\"请输入你的用户名：\")if name == \"admin\": print(\"管理员登录！\")num = int(input(\"请输入你的年龄：\"))print(num,type(num)) 五、输入年份判断生肖year = int(input(\"请输入一个要查询的年份：\"))if year % 12 == 2: print(\"今年是狗年\")elif year % 12 == 3: print(\"今年是猪年\")elif year % 12 == 4: print(\"鼠年\")elif year % 12 == 5: print(\"牛年\")elif year % 12 == 6: print(\"虎年\")elif year % 12 == 7: print(\"兔年\")elif year % 12 == 8: print(\"龙年\")elif year % 12 == 9: print(\"蛇年\")elif year % 12 == 10: print(\"马年\")elif year % 12 == 11: print(\"羊年\")elif year % 12 == 0: print(\"猴年\")elif year % 12 == 1: print(\"鸡年\") 六、彩票抽奖用户输入一个两位数，输入的数值与指定的号码对比，如果两个数值一样，就是一等奖如果两个数一样，郸顺序不一样，是二等奖如果只有一个数值一样，不得奖import random #引入随机数luck_num = random.randint(10,99)luck_num_g = luck_num % 10luck_num_s = luck_num //10buy_num = int(input(\"请输入一个两位数：\"))if buy_num == luck_num: print(\"一等奖\")elif buy_num % 10 == luck_num_s and buy_num //10 == luck_num_g: print(\"二等奖\")else: print(\"遗憾,没中奖\") ​","permalink":"http://jj1m8.github.io/2020/04/03/day-5%EF%BC%9A%E5%B0%8F%E7%BB%83%E4%B9%A0%E4%B8%8E%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day 4：数据类型转换与运算","date":"2020/04/03","text":"一、向集合转换var=1 #整型，浮点型，复数，boolval = set(var)print(val,type(val)) #报错！所有数值类型不能转化成集合var = \"hello\" val = set(var)print(val,type(val)) 总结：所有数值类型不能转化成集合所有容器类型都可以字典只能转化键 二、向字典转换var = \"\"val = dict(var)print(val, type(val))var = [[1,\"hello\"],[2,\"word\"]]val = dict(var)print(val, type(val)) 总结：所有字符类型不能转换容器类型只要是空都可以列表中[[1,”hello”],[2,”word”]]，嵌套二级列表，有且只有两个元素才可以 三、数值运算// 取整（取结果，去掉余数的意思）** 幂运算 7/5 版本2中是1，版本3中是1.4 （其余运算类似c） 四、逻辑运算两个相等是全等于，必须数值相同 为True a=1.0b=1print(a==b) #结果为True （其余运算类似c） 五、赋值运算a**=3 等于 a=a**3 六、逻辑运算and、or、not、xor（^） 七、成员运算在容器中in、不在容器中not in var = [1,2,3,4,5]print(6 in var)","permalink":"http://jj1m8.github.io/2020/04/03/day-4%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day3：数据类型转换","date":"2020/04/03","text":"一、向int转换#数据类型转换：强制类型转换，自动类型转换。#自动类型转换： #朝着让精度更加大的方向进行转换 #自动转换不需要人工干预 #都发生在运算以及判断中#强制类型转换：（手动类型转换） #随着程序员的意图进行转换\"\"\"可以转换： float bool str 纯数字字符串 不可转换： complex str 非纯数字 list tuple set dict容器类型 str 有序可变 list 有序可变 tuple 有序不可变 set 无序不可变 dict 无序可变\"\"\" 二、向float转换与int转换相同 三、向complex转换\"\"\"向复数类型转化 int 可以 float 可以 bool 可以 str 纯数字可以 list 不行 tuple 不行 set 不行 dict 不行\"\"\" 四、向bool类型转换\"\"\"向bool类型转换（所有的类型都可以转换为bool） 0 --- False 1 --- True 字符串只有\"\"空字符串才能转换为Falselist也是只有空列表才转换为Falsetuplesetdict一般用于判断用，判断是否为空\"\"\" 五、向list进行转换\"\"\"int floatcomplex 不可以转换str 可以tupledictset['c', 'a', 'b'] &lt;class 'list'&gt; 只转换字典的键不转换值\"\"\" 六、向str转换所有都可以转换，在最外边加上双引号 字典在转换时： #{‘a’: 1, ‘b’: 2, ‘c’: 3} &lt;class ‘str’&gt; 七、向tuple转换\"\"\"向tuple进行转换，如，int float bool 不能转换，不能迭代（因为不是容器）其他容器类型都可以转换(str是一个特殊的容器)str： #('1', ',', '2', ',', '3') &lt;class 'tuple'&gt;dict： #('c', 'a', 'b') &lt;class 'tuple'&gt;只有键值\"\"\"","permalink":"http://jj1m8.github.io/2020/04/03/day3%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day2：基本数据类型列表、集合、元组、字典","date":"2020/04/03","text":"一、列表#列表， 使用标识符[]，每一个元素使用逗号区分，可以随时修改#列表可以嵌套列表#对应于数组使用，功能比数组强大list1 = '[1,2,3,\"a\",\"b\",(1,2),[1,2,3]]'print(list1,type(list1))#索引 0 1 2 3 4 5 （正向）index# -5 -4 -3 -2 -1（反向）list2 = [\"a\",\"b\",\"c\",\"d\"]ver = list2[1]print(ver,type(ver))list3 = [1,2,3,[\"a\",\"b\",\"c\",\"d\"]]ver = list3[3][1]print(ver,type(ver))list4 = [1,2,3,[\"a\",\"b\",\"c\",\"d\"],True]ver = list4[4] = Falseprint(ver)print(list4) 二、元组#元组：是一些列元素的组合，用逗号分割，标识符是，逗号，并且定义之后元素不能再进行修改#其他用法与列表类似tuple1 = (1,2,3,4,5,[6,7,8])print(tuple1)print(tuple1[1])tuple1[5][0]=10 #元组不能修改，但是元组内的列表可以修改print(tuple1)#注意：b=(1)print(type(b)) #int型，没有标识符时就不是元组c=(1,)print(type(c)) 三、集合#一种特定数据的组合，所有元素不能重复，不能修改set1=&#123;1,2,3,4,3,1&#125;print(set1) #&#123;1, 2, 3, 4&#125; 集合会自动去重复#多用于计算补集 交集 并集 子集 超集。。。四、字典#有映射关系的无序的组合，可以修改dict1 = &#123;\"啊\":\"one\" , \"我开炮\":\"连长\" , \"花和尚\":\"鲁智深\"&#125;print(dict1)ver=dict1[\"啊\"]print(ver,type(ver))#冒号前面的是键值，键值是唯一的，并且不可以修改，#冒号后面的才是可以修改的dict1[\"啊\"]=\"gggg\"print(dict1)#字典嵌套只能使用在，冒号后面上，键值必须唯一dict2 = &#123;\"四大名著\":&#123;\"西游记\":\"吴承恩\",\"水浒传\":\"罗贯中\",\"红楼梦\":\"曹雪芹\"&#125;&#125;print(dict2[\"四大名著\"])","permalink":"http://jj1m8.github.io/2020/04/03/day2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8%E3%80%81%E9%9B%86%E5%90%88%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8/","photos":[]},{"tags":[{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}],"title":"day1：python的常用命名方式、语句分类、变量使用","date":"2020/04/03","text":"一、python文件命名方式#常常使用驼峰命名法或者是下划线分割法#并且不能使用关键字#文件名：使用中文不会报错，除了第一天的代码，第二天开始都不要使用中文 #1.可以使用中文 #2.可以使用数字但是不要全部是数字 #3.可以使用_或者-等分割字符分割 #4,文件名要有描述性 #5.不要和系统关键字冲突# python后缀文件#.py 经常使用的脚本文件#.pyc 临时文件#.pyw 开发纯图形化界面程序的文件 二、python语句分分类、注释的使用#注释：#单行注释使用##多行注释使用\"\"\"这样里边的内容都是注释我是多行注释，在run的时候不会执行里边的内容\"\"\"#语句分类：#单行语句、代码块print(\"oaoaoaoaoaoaoaoao sdadfasfsa\")#代码组if 1: print(\"true\") print(\"我是真\")# 变量看做是一个容器# a = \"hello word\"# print(a)# print(\"a\")#print会自己换行#使用ctrl+？可以实现多行注释， 三、变量的命名方式 #1、python3版本支持中文命名，一般不用 #2、只能以数字，字母下划线组成， #3、数字不能作为开头 #4、下划线作为开头是由特殊意义的，__私有，代表了集成式的继承特性 #5、python严格区分大小写 #6、变量命名需要有描述性 #7、不能与关键字冲突age1=18age2=18age3=18print(age1,id(age1))print(age2,id(age2))print(age3,id(age3))age1=age2=age3=18print(age1,id(age1))print(age2,id(age2))print(age3,id(age3))#-5，会优先去看内存中是否有，如果有，那么地址就是一样的name,age,sex=\"name\",18,\"women\" #变量可以对应接收print(name)print(age)print(sex)a,*b,c=1,2,3,4 #b,看做一个垃圾站，接收所有没人要的值，取成首地址，看成数组print(a)print(b)print(c) 四、系统默认有6个基本类型1、Number 类型 int float 3.141526535 bool True False complex 复数（由实部+虚部组成） a=实数+虚数（j） 1+1i 2、string 字符型 单引号定义 &apos;&apos; 双引号定义 &quot;&quot; 三引号 #转义字符 3、list 列表型 a = [1,2,3] 4、tuple 元组型 a = (1,2,3) a = ()#空元组 5、dict 字典型 有映射关系的无序的数据组合 有空字典 a = {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3} 6、set 集合型 一组特定数据的无序集合，所有数据不会重复 a = {1,2,3,4,5}","permalink":"http://jj1m8.github.io/2020/04/03/day1%EF%BC%9Apython%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F%E3%80%81%E8%AF%AD%E5%8F%A5%E5%88%86%E7%B1%BB%E3%80%81%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8/","photos":[]},{"tags":[{"name":"编码之外","slug":"编码之外","permalink":"http://jj1m8.github.io/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"}],"title":"从高考到程序员","date":"2020/04/03","text":"1、前言首先，本人是一名物联网工程专业大一的学生。可以说我是去年刚刚才走出高中、迈进大学的校门的，我知道我还不能算是一名程序员！我知道我还不能算是一名程序员！我知道我还不能算是一名程序员！但我有着一颗成为程序员的心，我相信，有一天我可以做到。 主要想写给自己，记录自己这一小段路的足迹。同时，也为一些将要进入大学的、志同道合的同学献上我的经验。 本人经历的虽然不多，但是在这有限的时间里，感触还是挺多的。 2、我的高中初中那一会，完全不把学习放在心上，每天只知道玩手机，看小说，打游戏。最后也不知道怎么就稀里糊涂的过去了，上了我们那排名最末尾的一所重点高中。到了高中，高一的时候还是没能静下心来学习，到了高二分重点班也没有机会能进，可以说是白白失去了很多机会。我想说：关键的时候一定要咬牙！真的，长点志气，别整天嬉皮笑脸的，如果自己都不想让自己变的更好的话，那谁也帮不了你，机会要自己去把握。 到了高二，我还在普通班里，要说不学习到不至于，只是没有去拼。等到我终于意识到学习是一件需要我使出浑身解数的时候，我在不知不觉中已经落后了别人太多了。在高二下到高考结束，我付出了不知多少的辛苦，我知道，比我努力的大有人在，我只求做到问心无愧。在我疯狂的学习之下，我终于赶上了班里的大部分人，最后最令我妈妈惊喜的是我也能考上一本。 现在回首我的高中，仿佛就是刚刚才过去，但也让人怀念。虽然高中浪费了很多的时间，但高中也留给了我无比珍贵的东西——敢于奋斗，敢于付出，敢于牺牲的精神。每个人都不是生来的天才，只有足够的努力才能让自己成为强者。千万别现在还年轻，此时不搏何时搏。卯足了劲，打他一个！ 建议： 在大学之前培养自己的兴趣爱好。–高一高二不忙，就多看看书，想办法开拓自己的视野，给自己找好目标，定好位就赢在了起跑线上了，聪明的人早早就规划好了自己。敢于尝试，敢于付出自己的时间。–哪怕是走错了路，选错了目标，花掉的时间也绝不是浪费。不要拘泥于自己的小世界。———用好网络，书籍等自己身边一切资源，你会发现世界远比你想象的丰富。高三要沉住气，做得住。一定要好好学英语!一定要好好学英语！一定要好好学英语！多看书！多看书！多看书！ 3、开始的迷茫刚开始进入大学，什么东西都是焕然一新的，（到了大学机会更要自己去把握。）无论如何，只要自己想，就去做,不要过多的在意他人的看法，大学里靠自己拼搏。 多多自学，用好互联网，靠自学！ 暂时，想说的就这么多，希望可以对他人有所帮助！","permalink":"http://jj1m8.github.io/2020/04/03/%E4%BB%8E%E9%AB%98%E8%80%83%E5%88%B0%E7%A8%8B%E5%BA%8F%E5%91%98/","photos":[]},{"tags":[],"title":"Hello World","date":"2020/04/02","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","permalink":"http://jj1m8.github.io/2020/04/02/hello-world/","photos":[]}],"categories":[],"tags":[{"name":"编码之外","slug":"编码之外","permalink":"http://jj1m8.github.io/tags/%E7%BC%96%E7%A0%81%E4%B9%8B%E5%A4%96/"},{"name":"日记","slug":"日记","permalink":"http://jj1m8.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"服务器","slug":"服务器","permalink":"http://jj1m8.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"内网穿透","slug":"内网穿透","permalink":"http://jj1m8.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"毕设","slug":"毕设","permalink":"http://jj1m8.github.io/tags/%E6%AF%95%E8%AE%BE/"},{"name":"python","slug":"python","permalink":"http://jj1m8.github.io/tags/python/"}]}